import{_ as e,c as a,o as i,a6 as t}from"./chunks/framework.DcJ2V8xd.js";const f=JSON.parse('{"title":"MakieTeX.jl","description":"","frontmatter":{},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":null}'),o={name:"index.md"},n=t(`<h1 id="MakieTeX.jl" tabindex="-1">MakieTeX.jl <a class="header-anchor" href="#MakieTeX.jl" aria-label="Permalink to &quot;MakieTeX.jl {#MakieTeX.jl}&quot;">​</a></h1><p>MakieTeX is a package that allows users to plot vector images - PDF, SVG, and TeX (which compiles to PDF) directly in Makie. It exposes two approaches: the <code>teximg</code> recipe which plots any LaTeX-like object, and the <code>CachedDocument</code> API which allows users to plot documents directly as <code>scatter</code> markers.</p><p>To see a list of all exported functions, types, and macros, see the <a href="./@ref api">API</a> page.</p><div class="language-@example vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">@example</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>using MakieTeX, CairoMakie</span></span>
<span class="line"><span></span></span>
<span class="line"><span>teximg(raw&quot;&quot;&quot;</span></span>
<span class="line"><span>\\begin{align*}</span></span>
<span class="line"><span>\\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}</span></span>
<span class="line"><span>\\end{align*}</span></span>
<span class="line"><span>&quot;&quot;&quot;)</span></span></code></pre></div><h2 id="Principle-of-operation" tabindex="-1">Principle of operation <a class="header-anchor" href="#Principle-of-operation" aria-label="Permalink to &quot;Principle of operation {#Principle-of-operation}&quot;">​</a></h2><h3 id="Rendering" tabindex="-1">Rendering <a class="header-anchor" href="#Rendering" aria-label="Permalink to &quot;Rendering {#Rendering}&quot;">​</a></h3><p>Rendering can occur either to a bitmap (for GL backends) or to a Cairo surface (for CairoMakie). Both of these have APIs (<a href="./@ref"><code>rasterize</code></a> and <a href="./@ref"><code>draw_to_cairo_surface</code></a>).</p><p>Each rendering format has its own complexities, so the rendering pipelines are usually separate. SVG uses librsvg, PDF and EPS use Poppler directly, and TeX uses the available local TeX render (if not, <code>tectonic</code> is bundled with MakieTeX) to render to a PDF, which then follows the Poppler pipeline.</p><p>A hypothetical future Typst backend would likely also be a Typst -&gt; PDF -&gt; Poppler pipeline. <a href="https://github.com/JuliaBinaryWrappers/Typst_jll.jl" target="_blank" rel="noreferrer">Typst_jll</a> already exists, so it would be fairly easy to bundle.</p><h3 id="Makie" tabindex="-1">Makie <a class="header-anchor" href="#Makie" aria-label="Permalink to &quot;Makie {#Makie}&quot;">​</a></h3><p>When rendering to Makie, MakieTeX rasterizes the document to a bitmap by default via the Makie attribute conversion pipeline (specifically <code>Makie.to_spritemarker</code>), and then Makie treats it like a general image scatter marker.</p><p><strong>HOWEVER</strong>, when rendering with CairoMakie, there is a function hook to get the correct marker for <em>Cairo</em> specifically, ignoring the default Makie conversion pipeline. This is <code>CairoMakie.cairo_scatter_marker</code>, and we overload it in <code>MakieTeX.MakieTeXCairoMakieExt</code> to get the correct marker. This also allows us to apply styling to SVG elements, but again <strong>ONLY IN CAIROMAKIE</strong>! This is a bit of an incompatibility and a breaking of the implicit promise from Makie that rendering should be the same across backends, but the tradeoff is (to me, at least) worth it.</p>`,12),s=[n];function r(l,p,c,d,h,u){return i(),a("div",null,s)}const m=e(o,[["render",r]]);export{f as __pageData,m as default};
